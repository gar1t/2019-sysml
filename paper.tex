\documentclass{article}

\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{hyperref}

% Use the following line for the initial blind version submitted for review:
\usepackage{sysml2019}

% If accepted, instead use the following line for the camera-ready submission:
%\usepackage[accepted]{sysml2019}

% The \sysmltitle you define below is probably too long as a header.
% Therefore, a short form for the running title is supplied here:
%\sysmltitlerunning{Guild AI: NEEDS A TITLE}

\begin{document}

\twocolumn[
\sysmltitle{Guild AI: Package management for machine learning models}

% List of affiliations: The first argument should be a (short)
% identifier you will use later to specify author affiliations
% Academic affiliations should list Department, University, City, Region, Country
% Industry affiliations should list Company, City, Region, Country

\begin{sysmlauthorlist}
\sysmlauthor{Garrett Smith}{guild}
\end{sysmlauthorlist}

\sysmlaffiliation{guild}{Guild AI, Chicago, Illinois, USA}

\sysmlcorrespondingauthor{Garrett Smith}{garrett@guild.ai}

% You may provide any keywords that you
% find helpful for describing your paper; these are used to populate
% the "keywords" metadata in the PDF but will not be shown in the document
\sysmlkeywords{Guild AI, SysML}

\vskip 0.3in

\begin{abstract}

  We present Guild AI, an open source toolkit that facilitates model
  reuse for application development by applying traditional software
  packaging constructs to the domain of machine learning. Package
  management strategies are central to successful software
  ecosystems. Examples include \href{https://www.npmjs.com/}{npm} for
  JavaScript, \href{https://wiki.debian.org/Apt}{APT} for Debian, and
  \href{https://pip.pypa.io}{pip} for Python. Such tools excel at
  creating traditional software packages. However, machine learning
  applications present unique requirements that call for tool
  specialization. Guild AI combines the proven effectiveness of
  package managers with novel features to enable machine learning
  model reuse for application development across a variety of use
  cases.

\end{abstract}
]

% this must go after the closing bracket ] following \twocolumn[ ...

% This command actually creates the footnote in the first column
% listing the affiliations and the copyright notice.
% The command takes one argument, which is text to display at the start of the footnote.
% The \sysmlEqualContribution command is standard text for equal contribution.
% Remove it (just {}) if you do not need this facility.

\printAffiliationsAndNotice{}  % leave blank if no need to mention equal contribution
%\printAffiliationsAndNotice{\sysmlEqualContribution} % otherwise use the standard text.

\section{Introduction}

Code reuse is a central tenet in software development and is supported
by myriad techniques, abstractions, and tools. Effective code reuse
allows developers to leverage prior work in a consistent, reliable
manner that saves time and improves software quality. In this paper we
consider code reuse in terms of \emph{packaged software} in the
context of machine learning.

\subsection{Traditional packaged software}

Packaged software is software that is organized in a way that can be
easily installed and used by \emph{users}. A user is a consumer of
software, rather than a producer or developer. A user may be software
developer, in the case of consuming software libraries or frameworks,
or she may be an end-user who uses software as a program using a
graphical or command line interface. In both cases, packaged software
may be provided in units that the user can install and start using
quickly and reliably.

This is an example of installing packaged software:

{\footnotesize
\begin{verbatim}
 $ pip install tensorflow
\end{verbatim}}

By running this command, a user is using a \emph{package manager}---in
this case the program \verb|pip|---to install a package named
\verb|tensorflow|. With this innocuous command, the user implicitly expects
a number of things:

\begin{itemize}
\item The Python module \verb|tensorflow| should be installed
\item Additional Python modules required by \verb|tensorflow| should
  also be installed
\item Installed software should work as expected on the target system
\item At a future date \verb|tensorflow| may be similarly uninstalled along
  with its no-longer-needed required packages
\item The act of installing and uninstalling \verb|tensorflow| should
  not break or otherwise destabilize other installed software on the
  target system
\end{itemize}

Such a package management facilities are essential to code reuse at
the system level. Package managers allow users to consume and manage
complex software systems with simple commands in a way that maintains
the integrity of other installed software. They support rapid
experimentation with new software as users are free to install, use,
and evaluate packages with the confidence that they can safely remove
that software later.

Package managers promote healthy software ecosystems by facilitating
software \emph{publishing}. Software authors use packaging tools to
create the installable software units---\emph{packages}---that are so
easily consumed by users. By publishing packaged software, developers
signify that their software will work as advertised if installed using
the supported tools.

Immense software ecosystems that are enabled by package managers
include Python, JavaScript, Ruby, Go, and R. The GNU/Linux operating
system itself is an ecosystem of package management ecosystems
including packaging schemes from Debian, RedHat, Gentoo, and Arch
distributions. Package managers are established cornerstones of
software reuse across languages and operating systems.

\subsection{Code reuse and machine learning models}

A \emph{machine learning model} is challenging to define as models
have different contexts. In the most general context, models are
mathematical concepts or language that represents a system
(needref). In the context of machine learning, models may be
represented by computer source code, either explicitly as declared
structures, or implicitly by way of executable instructions that
perform model related tasks. A \emph{trained model} is a model that
has learned some representation of a system through the process of
computer based optimization.

For the purpose of our discussion, a machine learning model is a
software representation of a specific mathetical concept that can be
trained by a computer. Models may be in various states:
\emph{uninitialized}, \emph{initialized}, \emph{partially trained},
\emph{fully trained}. Regardless of state, the distinguishing feature
of machine learning models for our purpose is that they support
runnable computer operations.

Models---and in particular \emph{trained models}--- are similar to
traditional software in that they can be executed to perform
computations. In fact, the purpose of training a model is to create a
computer program. The difference between a trained model and a human
authored program is one of method: a trained model is learned by an
algorithm while a human authored program is written manually.

While models may be represented in part by traditional installable
software---e.g. a TensorFlow program that imperatively defines a model
graph structure when run---models require more to be construed as
reusable code: \emph{models must be trainable on novel data}.

Table \ref{software-vs-models} compares traditional software with
reusable models.

\begin{table}[h!]
  \begin{center}
    \caption{Traditional software vs reusable models.}
    \label{software-vs-models}
    \begin{tabular}{l|l}
      Traditional software & Installed code
      Reusable models & Installed code + trainable on novel data
    \end{tabular}
  \end{center}
\end{table}

The remainder of this paper will outline an approach to package
management applied to machine learning models that incorporates
\emph{model operations} and \emph{run management} as a central enabler
of model code reuse.


TODO:

- What problem is being solved?

Need to define reuse. Start with traditional softwar reuse and make it
clear that Guild addresses model reuse. What is model reuse?

- How package managers facilitate code reuse

Apply analogy of system packaging and the importance of formalizing
the process with protocols and reference implementations.

\subsection{Related Work}

- How machine learning models are distributed today (pip, GitHub
projects)

- Packaging tools

- Frameworks and libraries

- TensorFlow Hub

- Keras Applications

- ???

\subsection{Differences}

- How is Guild different from these cited projects?

- Include model and operation definitions

- Reuse through distribution and patching

- Federation (protocol driven, intelligence moved to the perimeter).

\section{Concepts}

\subsection{Projects}

\subsection{Packages}

\subsection{Models}

\subsection{Operations}

\subsection{Flags}

\subsection{Resources}

\subsection{Runs}

\subsection{Environments}

\subsection{Workflows}

\section{Use Cases}

\subsection{Publish a Model for Reuse}

\subsection{Use a Published Model}

\subsection{Package Third Party Models}

\subsection{Team Collaboration}

\subsection{Streamline Model Developer Workflow}

\subsection{Manage Run Artifacts}

\section{Using Models}

\subsection{Packaged Models}

\subsection{Project Models}

\subsection{Listing Available Models and Operations}

\subsection{Getting Help for Models}

\subsection{Running Operations}

\subsection{Viewing and Comparing Runs}

\subsection{Exporting Model Artifacts}

\section{Managing Runs}

- What is a run (from an operation)

- What is a run concretely (i.e. directory, etc.)

\subsection{Starting a Run}

\subsection{Listing Runs}

\subsection{Getting Run Information}

\subsection{Deleting Runs}

\subsection{Archiving and Restoring Runs}

\subsection{Run Dependencies}

\subsection{Remote Runs}

\section{Developing Reusable Models}

\subsection{Developing a Model from Scratch}

- How to choose a model boundary?

- How to define operations

\subsection{Customizing Models}

\subsubsection{Model Inheritance}

\subsubsection{Configuration Mixins}

\subsubsection{Modifying Operations}

\subsubsection{Modifying Flag Values}

\subsubsection{Reusing Python Main Modules}

\subsection{Packaging}

\subsection{Patching Strategies}

\section{Implementation}

- Core - written in Python, etc.

\subsection{Command Line Interface}

\subsection{Configuration Processing}

\subsection{Resource Resolution}

\subsection{Model Testing}

\subsection{Packaging and Distribution}

\subsection{Run Indexing}

\subsection{Run Visualization}

\subsection{Remote Environments}

\section{Status}

- Apache 2.0

\subsection{History and Lessons Learned}

- Workshops
- User feedback

\subsection{Packages}

- slim, object-detection, mnist, hello

\subsection{Early Use}

\section{Summary}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Typography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Delete this to end of doc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Verbatim}

{\footnotesize
\begin{verbatim}
dvips -Ppdf -tletter -G0 -o paper.ps paper.dvi
ps2pdf paper.ps
another line yo
\end{verbatim}}

You can copy the file by running \verb|cp foo bar| where \textit{foo}
is some file you want to copy and \textit{bar} is something else.

\subsection{Italics}

\textit{Proceedings of the $\mathit{2}^{nd}$ SysML Conference}

And \emph{this is for emphasis!}

\subsection{Bold}

I will \textbf{make this bold} yo.

\subsection{Teletype}

Set the value to \texttt{accepted} and everything will be okay.

\subsection{Dots}

ldots: \ldots

dots: \dots

\subsection{Less than, greater than}

\textless{}email@domain.com\textgreater{}

\subsection{Footnotes}

You can use footnotes\footnote{Footnotes should be complete
  sentences.} which will be super awesome. Don't ask me how it works.

\subsection{Tables}

\begin{table}[t]
\caption{Classification accuracies for naive Bayes and flexible
Bayes on various data sets.}
\label{sample-table}
\begin{center}
\begin{small}
\begin{sc}
\begin{tabular}{lcccr}
\toprule
Data set & Naive & Flexible & Better? \\
\midrule
Breast    & 95.9$\pm$ 0.2& 96.7$\pm$ 0.2& $\surd$ \\
Cleveland & 83.3$\pm$ 0.6& 80.0$\pm$ 0.6& $\times$\\
Glass2    & 61.9$\pm$ 1.4& 83.8$\pm$ 0.7& $\surd$ \\
Credit    & 74.8$\pm$ 0.5& 78.3$\pm$ 0.6&         \\
Horse     & 73.3$\pm$ 0.9& 69.7$\pm$ 1.0& $\times$\\
Meta      & 67.1$\pm$ 0.6& 76.5$\pm$ 0.5& $\surd$ \\
Pima      & 75.1$\pm$ 0.6& 73.9$\pm$ 0.5&         \\
Vehicle   & 44.9$\pm$ 0.6& 61.5$\pm$ 0.4& $\surd$ \\
\bottomrule
\end{tabular}
\end{sc}
\end{small}
\end{center}
\vskip -0.1in
\end{table}

\subsection{Citations}

I really like TensorFlow \cite{tensorflow2015-whitepaper}.

\bibliography{paper}
\bibliographystyle{sysml2019}

\end{document}
